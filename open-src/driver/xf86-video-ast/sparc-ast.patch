--- a/src/Makefile.am	Fri Oct  5 08:24:21 2012
+++ b/src/Makefile.am	Fri Oct  5 08:24:40 2012
@@ -43,4 +43,5 @@
 	ast_tool.c 	\
 	ast_vgatool.c 	\
 	ast_vgatool.h   \
+	ast_sparc_driver.c   \
         compat-api.h
--- a/src/ast.h	Fri Oct  5 08:25:02 2012
+++ b/src/ast.h	Fri Oct  5 08:38:59 2012
@@ -20,9 +20,17 @@
  * PERFORMANCE OF THIS SOFTWARE.
  */
 
+#ifndef AST_H
+#define AST_H
+
 #include <string.h>
 #include <stdlib.h>
+#include <sys/visual_io.h>
 
+#ifdef __sparc
+#define __sparc__ 1
+#endif
+
 #ifdef HAVE_XAA_H
 #include "xaa.h"
 #endif
@@ -267,12 +275,93 @@
     Atom		xvGammaRed, xvGammaGreen, xvGammaBlue;
 #endif
 
+#if defined(__sparc__)
+    char               *deviceName;
+    int                fd;
+#endif
+
 } ASTRec, *ASTRecPtr, *ASTPtr;
 
 #define ASTPTR(p) ((ASTRecPtr)((p)->driverPrivate))
 
+#if defined(__sparc__)
+#ifndef VIS_GETPCICONFIG
+
+/*
+ * These definitions will be removed when they are included in the
+ * visual_io.h
+ */
+#define VIS_GETVIDEOMODENAME            (VIOC | 12)
+#define VIS_STOREVIDEOMODENAME          (VIOC | 13)
+#define VIS_MAX_VMODE_LEN               48
+
+typedef struct  vis_video_mode {
+        char            mode_name[VIS_MAX_VMODE_LEN];
+        uint32_t        vRefresh;
+        char            pad[96];
+} vis_video_mode_t;
+
+
+#define VIS_GETPCICONFIG               (VIOC | 14)
+
+typedef struct  vis_pci_cfg {
+       uint16_t        VendorID;
+        uint16_t        DeviceID;
+        uint16_t        Command;
+        uint16_t        Status;
+        uint8_t         RevisionID;
+        uint8_t         ProgIF;
+        uint8_t         SubClass;
+       uint8_t         BaseClass;
+
+        uint8_t         CacheLineSize;
+        uint8_t         LatencyTimer;
+        uint8_t         HeaderType;
+        uint8_t         BIST;
+
+       uint32_t        bar[6];
+        uint32_t        CIS;
+        uint16_t        SubVendorID;
+        uint16_t        SubSystemID;
+        uint32_t        ROMBaseAddress;
+
+        uint8_t         CapabilitiesPtr;
+        uint8_t         Reserved_1[3];
+        uint32_t        Reserved_2;
+
+       uint8_t         InterruptLine;
+        uint8_t         InterruptPin;
+        uint8_t         MinimumGrant;
+        uint8_t         MaximumLatency;
+
+       uint8_t         pad[100];
+} vis_pci_cfg_t;
+
+
+#define VIS_SETIOREG                    (VIOC | 17)
+#define VIS_GETIOREG                    (VIOC | 18)
+
+typedef struct vis_io_reg {
+        uchar_t         offset;
+        uchar_t         value;
+} vis_io_reg_t;
+#endif
+extern struct pci_device *ASTGetPciInfo(ASTRecPtr);
+extern ScrnInfoPtr        ASTAllocScreen(DriverPtr, GDevPtr);
+extern pointer           ASTMapVidMem(ScrnInfoPtr, unsigned int, PCITAG,
+                                               unsigned long, unsigned long);
+extern void              ASTUnmapVidMem(ScrnInfoPtr, pointer, unsigned long);
+extern void              ASTNotifyModeChanged(ScrnInfoPtr);
+extern void              ASTSaveHW(ScrnInfoPtr);
+extern void              ASTRestoreHW(ScrnInfoPtr);
+
+#endif
+
 /* Include Files */
 #include "ast_mode.h"
 #include "ast_vgatool.h"
 #include "ast_2dtool.h"
 #include "ast_cursor.h"
+
+#endif /* AST_H */
+
--- a/src/ast_cursor.c	Fri Oct  5 08:39:16 2012
+++ b/src/ast_cursor.c	Fri Oct  5 08:40:03 2012
@@ -86,7 +86,11 @@
 
     infoPtr->Flags = HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
                      HARDWARE_CURSOR_INVERT_MASK |        
+#if     !defined(__sparc__)
                      HARDWARE_CURSOR_BIT_ORDER_MSBFIRST;
+#else
+		     0;
+#endif
 
     infoPtr->MaxWidth  = MAX_HWC_WIDTH;
     infoPtr->MaxHeight = MAX_HWC_HEIGHT;
--- a/src/ast_driver.c	Fri Oct  5 08:40:19 2012
+++ b/src/ast_driver.c	Fri Oct  5 08:46:21 2012
@@ -106,7 +106,7 @@
 static ModeStatus ASTValidMode(SCRN_ARG_TYPE arg, DisplayModePtr mode, Bool verbose, int flags);
 
 /* Internally used functions */
-static Bool ASTGetRec(ScrnInfoPtr pScrn);
+extern Bool ASTGetRec(ScrnInfoPtr pScrn);
 static void ASTFreeRec(ScrnInfoPtr pScrn);
 static Bool ASTSaveScreen(ScreenPtr pScreen, Bool unblack);
 static Bool ASTCloseScreen(CLOSE_SCREEN_ARGS_DECL);
@@ -270,7 +270,7 @@
       return FALSE;
     }
 
-#ifndef XSERVER_LIBPCIACCESS
+#if !defined(XSERVER_LIBPCIACCESS) && !defined(__sparc__)
    /*
     * This probing is just checking the PCI data the server already
     * collected.
@@ -280,6 +280,8 @@
     }
 #endif
 
+#if !defined(__sparc__)
+
     numUsed = xf86MatchPciInstances(AST_NAME, PCI_VENDOR_AST,
 				   ASTChipsets, ASTPciChipsets,
 				   devSections, numDevSections,
@@ -338,7 +340,39 @@
     } /* end of if flags */	   
 
     free(usedChips);
+#else
 
+    if (flags & PROBE_DETECT) {
+        foundScreen = TRUE;
+    } else {
+        for (i = 0; i < numDevSections; i++) {
+
+           ScrnInfoPtr pScrn = NULL;
+
+           /* Allocate new ScrnInfoRec and claim the slot */
+           if (pScrn = ASTAllocScreen(drv, devSections[i])) {
+               pScrn->driverVersion = AST_VERSION;
+               pScrn->driverName = AST_DRIVER_NAME;
+               pScrn->name = AST_NAME;
+
+               pScrn->Probe = ASTProbe;
+               pScrn->PreInit = ASTPreInit;
+               pScrn->ScreenInit = ASTScreenInit;
+               pScrn->SwitchMode = ASTSwitchMode;
+               pScrn->AdjustFrame = ASTAdjustFrame;
+               pScrn->EnterVT = ASTEnterVT;
+               pScrn->LeaveVT = ASTLeaveVT;
+               pScrn->FreeScreen = ASTFreeScreen;
+               pScrn->ValidMode = ASTValidMode;
+
+               foundScreen = TRUE;
+           }
+       }
+    }
+    free(devSections);
+#endif
+
+
     return foundScreen;
 }
 
@@ -372,6 +406,10 @@
 
    pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
 
+#if defined(__sparc__)
+   pEnt->location.type = BUS_PCI;
+#endif 
+
    if (flags & PROBE_DETECT) {
        ASTProbeDDC(pScrn, pEnt->index);
        return TRUE;
@@ -474,7 +512,12 @@
    /* Fill AST Info */
    pAST = ASTPTR(pScrn);
    pAST->pEnt    = xf86GetEntityInfo(pScrn->entityList[0]);
+#if !defined(__sparc__)
    pAST->PciInfo = xf86GetPciInfoForEntity(pAST->pEnt->index);
+#else
+   pAST->PciInfo = ASTGetPciInfo(pAST);
+#endif
+
 #ifndef XSERVER_LIBPCIACCESS
    pAST->PciTag  = pciTag(pAST->PciInfo->bus, pAST->PciInfo->device,
 			  pAST->PciInfo->func);
@@ -528,12 +571,13 @@
     /* "Patch" the PIOOffset inside vgaHW in order to force
      * the vgaHW module to use our relocated i/o ports.
      */
-
+#if !(defined(__sparc__))
 #if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 12
     VGAHWPTR(pScrn)->PIOOffset = /* ... */
 #endif
        	pAST->PIOOffset =
 	pAST->IODBase + PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO) - 0x380;
+#endif
 	
     pAST->RelocateIO = (IOADDRESS)(PCI_REGION_BASE(pAST->PciInfo, 2, REGION_IO) + pAST->IODBase);
 	
@@ -823,6 +867,10 @@
 
    vFillASTModeInfo (pScrn);      
 
+#if (defined(__sparc__))
+   ASTNotifyModeChanged(pScrn);
+#endif
+
    ASTSave(pScrn);     
    if (!ASTModeInit(pScrn, pScrn->currentMode)) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Mode Init Failed \n");      	  	
@@ -1166,7 +1214,7 @@
  * These two functions create and destroy that private data.
  *
  */
-static Bool
+Bool
 ASTGetRec(ScrnInfoPtr pScrn)
 {
    if (pScrn->driverPrivate)
--- a/src/ast_tool.c	Fri Oct  5 08:47:11 2012
+++ b/src/ast_tool.c	Fri Oct  5 08:53:50 2012
@@ -59,16 +59,28 @@
 Bool ASTMapMMIO(ScrnInfoPtr pScrn);
 void ASTUnmapMMIO(ScrnInfoPtr pScrn);
 
+#if defined(__sparc__)
+extern pointer ASTMapVidMem(ScrnInfoPtr, unsigned int, PCITAG,
+                                 unsigned long, unsigned long);
+extern void    ASTUnmapVidMem(ScrnInfoPtr, pointer, unsigned long);
+#endif /* __sparc__ */
+
+
 Bool
 ASTMapMem(ScrnInfoPtr pScrn)
 {
    ASTRecPtr pAST = ASTPTR(pScrn);
 
-#ifndef XSERVER_LIBPCIACCESS
+#if !defined(XSERVER_LIBPCIACCESS) || defined(__sparc__)
+#if !defined(__sparc__)
    pAST->FBVirtualAddr = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
 				 pAST->PciTag,
 				 pAST->FBPhysAddr, pAST->FbMapSize);
 #else
+   pAST->FBVirtualAddr = ASTMapVidMem(pScrn, VIDMEM_FRAMEBUFFER, NULL,
+                                pAST->FBPhysAddr, pAST->FbMapSize);
+#endif /* sparc */
+#else
    {
      void** result = (void**)&pAST->FBVirtualAddr;
      int err = pci_device_map_range(pAST->PciInfo,
@@ -94,10 +106,14 @@
 {
    ASTRecPtr pAST = ASTPTR(pScrn);
 
-#ifndef XSERVER_LIBPCIACCESS 
+#if !defined(XSERVER_LIBPCIACCESS) || defined(__sparc__)
+#if !defined(__sparc__)
    xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pAST->FBVirtualAddr,
 		   pAST->FbMapSize);
 #else
+   ASTUnmapVidMem(pScrn, (pointer)pAST->FBVirtualAddr, pAST->FbMapSize);
+#endif
+#else
    pci_device_unmap_range(pAST->PciInfo, pAST->FBVirtualAddr, pAST->FbMapSize);
 #endif
 		   
@@ -110,7 +126,7 @@
 ASTMapMMIO(ScrnInfoPtr pScrn)
 {
    ASTRecPtr pAST = ASTPTR(pScrn);
-#ifndef XSERVER_LIBPCIACCESS
+#if !defined(XSERVER_LIBPCIACCESS) || defined(__sparc__)
    int mmioFlags;
 
 #if !defined(__alpha__)
@@ -119,12 +135,16 @@
    mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT | VIDMEM_SPARSE;
 #endif
 
-
+#if !defined(__sparc__)
    pAST->MMIOVirtualAddr = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
 				         pAST->PciTag,
 				         pAST->MMIOPhysAddr, pAST->MMIOMapSize);
-
 #else
+   pAST->MMIOVirtualAddr = ASTMapVidMem(pScrn,
+                        VIDMEM_MMIO | VIDMEM_READSIDEEFFECT, NULL,
+                        pAST->MMIOPhysAddr, pAST->MMIOMapSize);
+#endif
+#else
    {
      void** result = (void**)&pAST->MMIOVirtualAddr;
      int err = pci_device_map_range(pAST->PciInfo,
@@ -149,10 +169,14 @@
 {
    ASTRecPtr pAST = ASTPTR(pScrn);
 
-#ifndef XSERVER_LIBPCIACCESS
+#if !defined(XSERVER_LIBPCIACCESS) || defined(__sparc__)
+#if !defined(__sparc__)
    xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pAST->MMIOVirtualAddr,
 		   pAST->MMIOMapSize);
 #else
+   ASTUnmapVidMem(pScrn, (pointer)pAST->MMIOVirtualAddr, pAST->MMIOMapSize);
+#endif
+#else
    pci_device_unmap_range(pAST->PciInfo, pAST->MMIOVirtualAddr, pAST->MMIOMapSize);
 #endif
    pAST->MMIOVirtualAddr = 0;
--- a/src/ast_vgatool.c	Fri Oct  5 08:54:04 2012
+++ b/src/ast_vgatool.c	Fri Oct  5 08:56:22 2012
@@ -449,6 +449,7 @@
 void
 ASTDisplayPowerManagementSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags)
 {
+#if !defined(__sparc__)
    ASTRecPtr pAST;
    UCHAR SEQ01, CRB6;
    ULONG ulData, ulTemp;
@@ -497,8 +498,8 @@
    {  
        SetIndexRegMask(SEQ_PORT,0x01, 0xDF, SEQ01);
        SetIndexRegMask(CRTC_PORT,0xB6, 0xFC, CRB6);
-   }    
-
+   }
+#endif    
 }
 
 
@@ -989,7 +990,7 @@
     { 0x0030, 0x00000040 },
     { 0x0028, 0x00000003 },
     { 0x000C, 0x00005a21 },
-    { 0x0034, 0x00007c03 },
+    { 0x0034, 0x00007c43 },
     { 0x0120, 0x00004c41 },
     { 0xffff, 0xffffffff },
 };
@@ -1042,7 +1043,7 @@
     { 0x0030, 0x00000040 },
     { 0x0028, 0x00000003 },
     { 0x000C, 0x00005a21 },
-    { 0x0034, 0x00007c03 },
+    { 0x0034, 0x00007c43 },
     { 0x0120, 0x00005061 },
     { 0xffff, 0xffffffff },
 };
@@ -2717,9 +2718,11 @@
 
    {
        /* Enable PCI */
+#if !defined(__sparc__)
        PCI_READ_LONG(pAST->PciInfo, &ulData, 0x04);
        ulData |= 0x03;
        PCI_WRITE_LONG(pAST->PciInfo, ulData, 0x04);       
+#endif
 
        /* Enable VGA */
        vEnableVGA(pScrn);
--- a/src/ast_vgatool.h	Fri Oct  5 08:56:37 2012
+++ b/src/ast_vgatool.h	Fri Oct  5 09:23:53 2012
@@ -19,7 +19,13 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+#ifndef ASTVGATOOL_H
+#define ASTVGATOOL_H
 
+#include <unistd.h>
+#include <stropts.h>
+
+
 /* VRAM Size Definition */
 #define VIDEOMEM_SIZE_08M	0x00800000
 #define VIDEOMEM_SIZE_16M	0x01000000
@@ -40,6 +46,96 @@
 #define DRAMTYPE_2Gx16		6
 #define DRAMTYPE_4Gx16		7
 
+#if defined(__sparc__)
+
+#define SET_IO_REG             0x1000
+#define GET_IO_REG             0x1001
+
+#define AR_PORT_WRITE          0x40
+#define MISC_PORT_WRITE        0x42
+#define VGA_ENABLE_PORT        0x43
+#define SEQ_PORT               0x44
+#define DAC_INDEX_READ         0x47
+#define DAC_INDEX_WRITE        0x48
+#define DAC_DATA               0x49
+#define GR_PORT                0x4E
+#define CRTC_PORT              0x54
+#define INPUT_STATUS1_READ     0x5A
+#define MISC_PORT_READ         0x4C
+
+static inline uchar_t
+_GetRegFromFd(uchar_t off, int fd)
+{
+       struct vis_io_reg   io_reg = {
+              .offset = off
+       };
+       ioctl(fd, VIS_GETIOREG, &io_reg);
+       return io_reg.value;
+}
+
+#define GetReg(off)            _GetRegFromFd(off, pAST->fd)
+
+#define SetReg(off, val)       do {                                    \
+                       struct vis_io_reg   io_reg = {                  \
+                              .offset = off,                           \
+                              .value = val                             \
+                       };                                              \
+                       ioctl(pAST->fd, VIS_SETIOREG, &io_reg);         \
+                       } while (0)
+
+#define GetIndexReg(off, index, val)   do {                            \
+                       struct vis_io_reg   io_reg = {                  \
+                              .offset = off,                           \
+                              .value = index                           \
+                       };                                              \
+                       ioctl(pAST->fd, VIS_SETIOREG, &io_reg);         \
+                       io_reg.offset = off+1;                          \
+                       ioctl(pAST->fd, VIS_GETIOREG, &io_reg);         \
+                       val = io_reg.value;                             \
+                       } while (0)
+
+#define SetIndexReg(off, index, val) do {                              \
+                       struct vis_io_reg   io_reg = {                  \
+                             .offset = off,                           \
+                              .value = index                           \
+                       };                                              \
+                       ioctl(pAST->fd, VIS_SETIOREG, &io_reg);         \
+                       io_reg.offset = off+1;                          \
+                       io_reg.value = val;                             \
+                       ioctl(pAST->fd, VIS_SETIOREG, &io_reg);         \
+                       } while (0)
+
+#define GetIndexRegMask(off, index, and, val) do {                     \
+                       struct vis_io_reg   io_reg = {                  \
+                              .offset = off,                           \
+                              .value = index                           \
+                       };                                              \
+                       ioctl(pAST->fd, VIS_SETIOREG, &io_reg);         \
+                       io_reg.offset = off+1;                          \
+                       ioctl(pAST->fd, VIS_GETIOREG, &io_reg);         \
+                       val = io_reg.value & and;                       \
+                       } while (0)
+
+#define SetIndexRegMask(off, index, and, val) do {                     \
+                       UCHAR __Temp;                                   \
+                       struct vis_io_reg   io_reg = {                  \
+                              .offset = off,                           \
+                              .value = index                           \
+                       };                                              \
+                       ioctl(pAST->fd, VIS_SETIOREG, &io_reg);         \
+                       io_reg.offset = off + 1;                        \
+                       ioctl(pAST->fd, VIS_GETIOREG, &io_reg);         \
+                       __Temp = (io_reg.value & and) | val;            \
+                       io_reg.offset = off;                            \
+                       io_reg.value = index;                           \
+                       ioctl(pAST->fd, VIS_SETIOREG, &io_reg);         \
+                       io_reg.offset = off+1;                          \
+                       io_reg.value = __Temp;                          \
+                       ioctl(pAST->fd, VIS_SETIOREG, &io_reg);         \
+                       } while (0)
+
+#else /* !__sparc__ */
+
 #define AR_PORT_WRITE		(pAST->MMIOVirtualAddr + 0x3c0)
 #define MISC_PORT_WRITE		(pAST->MMIOVirtualAddr + 0x3c2)
 #define VGA_ENABLE_PORT		(pAST->MMIOVirtualAddr + 0x3c3)
@@ -72,6 +168,7 @@
 						__Temp = (MMIO_IN8(base, 1)&(and))|(val);	\
 						SetIndexReg(base,index,__Temp);			\
 						}
+#endif
 
 #define VGA_GET_PALETTE_INDEX(index, red, green, blue) \
 { \
@@ -166,3 +263,6 @@
         *(ULONG *) (pAST->MMIOVirtualAddr + 0xF000) = 0x1;	\
         *(ULONG *) (pAST->MMIOVirtualAddr + 0x10000 + ((addr) & 0x0000FFFF)) = (data);	\
 }
+
+#endif /* ASTVGATOOL_H */
+
--- a/src/ast_vgatool.c	Fri Oct  5 09:36:40 2012
+++ b/src/ast_vgatool.c	Fri Oct  5 09:38:03 2012
@@ -3015,9 +3015,11 @@
     pAST = ASTPTR(pScrn);    
 
     /* Enable PCI */
+#if    !defined(__sparc__)
     PCI_READ_LONG(pAST->PciInfo, &ulData, 0x04);
     ulData |= 0x03;
     PCI_WRITE_LONG(pAST->PciInfo, ulData, 0x04);       
+#endif
     	
     /* init DRAM if no F/W */
     /* TODO */
@@ -3108,9 +3110,11 @@
     if (!xf86IsPrimaryPci(pAST->PciInfo))
     {
        /* Enable PCI */
+#if !defined(__sparc__)
        PCI_READ_LONG(pAST->PciInfo, &ulData, 0x04);
        ulData |= 0x03;
        PCI_WRITE_LONG(pAST->PciInfo, ulData, 0x04);
+#endif
 
        outb(pAST->RelocateIO + 0x43, 0x01);
        outb(pAST->RelocateIO + 0x42, 0x01);	    
--- a/src/ast_driver.c	Fri Oct 19 09:56:16 2012
+++ b/src/ast_driver.c	Fri Oct 19 09:57:04 2012
@@ -645,8 +645,10 @@
    }
    else    	
    {  
+#if     !(defined(__sparc__))
        /* Enable VGA MMIO Access */	   
        vEnableASTVGAMMIO(pScrn);
+#endif
  	    	
        /* Init VGA Adapter */
        if (!xf86IsPrimaryPci(pAST->PciInfo))
