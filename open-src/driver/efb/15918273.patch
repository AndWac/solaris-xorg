--- src/radeon_output.c	Tue Jan 29 12:13:13 2013
+++ src/radeon_output.c	Tue Jan 29 15:30:36 2013
@@ -300,7 +300,7 @@
 		   INREG(DDCReg) & ~(RADEON_GPIO_EN_0));
 	    usleep(15000);
 
-	    MonInfo = xf86DoEDID_DDC2(pScrn->scrnIndex, radeon_output->pI2CBus);
+	    MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
 
 	    OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_1);
 	    OUTREG(DDCReg, INREG(DDCReg) | RADEON_GPIO_EN_0);
@@ -323,7 +323,7 @@
 	    if (MonInfo)  break;
 	}
     } else if (radeon_output->pI2CBus && info->ddc2 && ((DDCReg == RADEON_LCD_GPIO_MASK) || (DDCReg == RADEON_MDGPIO_EN_REG))) {
-         MonInfo = xf86DoEDID_DDC2(pScrn->scrnIndex, radeon_output->pI2CBus);
+         MonInfo = xf86OutputGetEDID(output, radeon_output->pI2CBus);
     } else {
 	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "DDC2/I2C is not properly initialized\n");
 	MonType = MT_NONE;

--- src/radeon_probe.h	Fri Dec 21 14:11:54 2012
+++ src/radeon_probe.h	Mon Jan 28 12:09:29 2013
@@ -45,7 +45,7 @@
 #include <X11/extensions/xf86misc.h>
 
 #include "xf86Crtc.h"
-
+#include "compat-api.h"
 #ifdef USE_EXA
 #include "exa.h"
 #endif
@@ -577,17 +577,17 @@
 
 /* radeon_driver.c */
 extern Bool                 RADEONPreInit(ScrnInfoPtr, int);
-extern Bool                 RADEONScreenInit(int, ScreenPtr, int, char **);
-extern Bool                 RADEONSwitchMode(int, DisplayModePtr, int);
+extern Bool                 RADEONScreenInit(SCREEN_INIT_ARGS_DECL);
+extern Bool                 RADEONSwitchMode(SWITCH_MODE_ARGS_DECL);
 #ifdef X_XF86MiscPassMessage
 extern Bool                 RADEONHandleMessage(int, const char*, const char*,
 					        char**);
 #endif
-extern void                 RADEONAdjustFrame(int, int, int, int);
-extern Bool                 RADEONEnterVT(int, int);
-extern void                 RADEONLeaveVT(int, int);
-extern void                 RADEONFreeScreen(int, int);
-extern ModeStatus           RADEONValidMode(int, DisplayModePtr, Bool, int);
+extern void                 RADEONAdjustFrame(ADJUST_FRAME_ARGS_DECL);
+extern Bool                 RADEONEnterVT(VT_FUNC_ARGS_DECL);
+extern void                 RADEONLeaveVT(VT_FUNC_ARGS_DECL);
+extern void                 RADEONFreeScreen(FREE_SCREEN_ARGS_DECL);
+extern ModeStatus           RADEONValidMode(SCRN_ARG_TYPE, DisplayModePtr, Bool, int);
 
 extern const OptionInfoRec *RADEONOptionsWeak(void);
 
--- src/radeon_driver.c	Fri Dec 21 14:11:56 2012
+++ src/radeon_driver.c	Mon Jan 28 12:08:28 2013
@@ -120,7 +120,7 @@
 #endif /* __sparc__ */
 
 				/* Forward definitions for driver functions */
-static Bool RADEONCloseScreen(int scrnIndex, ScreenPtr pScreen);
+static Bool RADEONCloseScreen(CLOSE_SCREEN_ARGS_DECL);
 static Bool RADEONSaveScreen(ScreenPtr pScreen, int mode);
 static void RADEONSave(ScrnInfoPtr pScrn);
 
@@ -3037,15 +3037,14 @@
 #endif
 }
 
-static void RADEONBlockHandler(int i, pointer blockData,
-			       pointer pTimeout, pointer pReadmask)
+static void RADEONBlockHandler(BLOCKHANDLER_ARGS_DECL)
 {
-    ScreenPtr      pScreen = screenInfo.screens[i];
-    ScrnInfoPtr    pScrn   = xf86Screens[i];
+    SCREEN_PTR(arg);
+    ScrnInfoPtr    pScrn   = xf86ScreenToScrn(pScreen);
     RADEONInfoPtr  info    = RADEONPTR(pScrn);
 
     pScreen->BlockHandler = info->BlockHandler;
-    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
+    (*pScreen->BlockHandler) (BLOCKHANDLER_ARGS);
     pScreen->BlockHandler = RADEONBlockHandler;
 
     if (info->VideoTimerCallback)
@@ -3136,10 +3135,9 @@
 
 
 /* Called at the start of each server generation. */
-Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen,
-                                int argc, char **argv)
+Bool RADEONScreenInit(SCREEN_INIT_ARGS_DECL)
 {
-    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr    pScrn = xf86ScreenToScrn(pScreen);
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
     xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
     int            hasDRI = 0;
@@ -3539,16 +3537,16 @@
 	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
 		       "Initializing Acceleration\n");
 	if (RADEONAccelInit(pScreen)) {
-	    xf86DrvMsg(scrnIndex, X_INFO, "Acceleration enabled\n");
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Acceleration enabled\n");
 	    info->accelOn = TRUE;
 	} else {
-	    xf86DrvMsg(scrnIndex, X_ERROR,
+	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Acceleration initialization failed\n");
-	    xf86DrvMsg(scrnIndex, X_INFO, "Acceleration disabled\n");
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Acceleration disabled\n");
 	    info->accelOn = FALSE;
 	}
     } else {
-	xf86DrvMsg(scrnIndex, X_INFO, "Acceleration disabled\n");
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Acceleration disabled\n");
 	info->accelOn = FALSE;
     }
 
@@ -3575,7 +3573,7 @@
 
 		if (xf86QueryLargestOffscreenArea(pScreen, &width, &height,
 					      0, 0, 0)) {
-		    xf86DrvMsg(scrnIndex, X_INFO,
+		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 			       "Largest offscreen area available: %d x %d\n",
 			       width, height);
 		}
@@ -3582,12 +3580,12 @@
 	    }
 #endif /* USE_XAA */
 	} else {
-	    xf86DrvMsg(scrnIndex, X_ERROR,
+	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Hardware cursor initialization failed\n");
-	    xf86DrvMsg(scrnIndex, X_INFO, "Using software cursor\n");
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using software cursor\n");
 	}
     } else {
-	xf86DrvMsg(scrnIndex, X_INFO, "Using software cursor\n");
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using software cursor\n");
     }
 
     /* DGA setup */
@@ -3629,8 +3627,10 @@
 #endif /* __sparc__ */
 
     /* Wrap pointer motion to flip touch screen around */
+#if 0
     info->PointerMoved = pScrn->PointerMoved;
     pScrn->PointerMoved = RADEONPointerMoved;
+#endif
 
     /* Colormap setup */
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
@@ -4743,9 +4743,9 @@
     return TRUE;
 }
 
-Bool RADEONSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
+Bool RADEONSwitchMode(SWITCH_MODE_ARGS_DECL)
 {
-    ScrnInfoPtr    pScrn       = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     RADEONInfoPtr  info        = RADEONPTR(pScrn);
     Bool           tilingOld   = info->tilingEnabled;
     Bool           ret;
@@ -4782,9 +4782,9 @@
 
     if (info->tilingEnabled != tilingOld) {
 	/* need to redraw front buffer, I guess this can be considered a hack ? */
-	xf86EnableDisableFBAccess(scrnIndex, FALSE);
+	xf86EnableDisableFBAccess(arg, FALSE);
 	RADEONChangeSurfaces(pScrn);
-	xf86EnableDisableFBAccess(scrnIndex, TRUE);
+	xf86EnableDisableFBAccess(arg, TRUE);
 	/* xf86SetRootClip would do, but can't access that here */
     }
 
@@ -4838,10 +4838,10 @@
 #endif
 
 /* Used to disallow modes that are not supported by the hardware */
-ModeStatus RADEONValidMode(int scrnIndex, DisplayModePtr mode,
+ModeStatus RADEONValidMode(SCRN_ARG_TYPE arg, DisplayModePtr mode,
                                      Bool verbose, int flag)
 {
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     RADEONInfoPtr info = RADEONPTR(pScrn);
     RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
 
@@ -4987,9 +4987,9 @@
     OUTREG(reg, Base);
 }
 
-void RADEONAdjustFrame(int scrnIndex, int x, int y, int flags)
+void RADEONAdjustFrame(ADJUST_FRAME_ARGS_DECL)
 {
-    ScrnInfoPtr    pScrn      = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
     RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
     xf86CrtcConfigPtr	config = XF86_CRTC_CONFIG_PTR(pScrn);
@@ -5021,9 +5021,9 @@
 /* Called when VT switching back to the X server.  Reinitialize the
  * video mode.
  */
-Bool RADEONEnterVT(int scrnIndex, int flags)
+Bool RADEONEnterVT(VT_FUNC_ARGS_DECL)
 {
-    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
     unsigned char *RADEONMMIO = info->MMIO;
     xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
@@ -5104,9 +5104,9 @@
 /* Called when VT switching away from the X server.  Restore the
  * original text mode.
  */
-void RADEONLeaveVT(int scrnIndex, int flags)
+void RADEONLeaveVT(VT_FUNC_ARGS_DECL)
 {
-    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
 
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
@@ -5149,9 +5149,9 @@
  * text mode, unmap video memory, and unwrap and call the saved
  * CloseScreen function.
  */
-static Bool RADEONCloseScreen(int scrnIndex, ScreenPtr pScreen)
+static Bool RADEONCloseScreen(CLOSE_SCREEN_ARGS_DECL)
 {
-    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
+    ScrnInfoPtr    pScrn = xf86ScreenToScrn(pScreen);
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
 
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
@@ -5240,12 +5240,12 @@
 
     pScreen->BlockHandler = info->BlockHandler;
     pScreen->CloseScreen = info->CloseScreen;
-    return (*pScreen->CloseScreen)(scrnIndex, pScreen);
+    return (*pScreen->CloseScreen)(CLOSE_SCREEN_ARGS);
 }
 
-void RADEONFreeScreen(int scrnIndex, int flags)
+void RADEONFreeScreen(FREE_SCREEN_ARGS_DECL)
 {
-    ScrnInfoPtr  pScrn = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
     
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, RADEON_LOGLEVEL_DEBUG,
--- src/radeon_dri.c	Fri Dec 21 14:11:55 2012
+++ src/radeon_dri.c	Mon Jan 28 12:11:57 2013
@@ -1585,15 +1585,15 @@
     return TRUE;
 }
 
-static Bool RADEONDRIDoCloseScreen(int scrnIndex, ScreenPtr pScreen)
+static Bool RADEONDRIDoCloseScreen(CLOSE_SCREEN_ARGS_DECL)
 {
-    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr    pScrn = xf86ScreenToScrn(pScreen);
     RADEONInfoPtr  info  = RADEONPTR(pScrn);
 
     RADEONDRICloseScreen(pScreen);
 
     pScreen->CloseScreen = info->DRICloseScreen;
-    return (*pScreen->CloseScreen)(scrnIndex, pScreen);
+    return (*pScreen->CloseScreen)(CLOSE_SCREEN_ARGS);
 }
 
 /* Finish initializing the device-dependent DRI state, and call
--- src/radeon_dga.c	Mon Jan 28 14:11:08 2013
+++ src/radeon_dga.c	Mon Jan 28 14:12:17 2013
@@ -295,7 +295,7 @@
 
 	pScrn->currentMode = info->CurrentLayout.mode;
 
-	RADEONSwitchMode(indx, pScrn->currentMode, 0);
+	RADEONSwitchMode(indx, pScrn->currentMode);
 #ifdef XF86DRI
 	if (info->directRenderingEnabled) {
 	    RADEONCP_STOP(pScrn, info);
@@ -308,7 +308,7 @@
 	    RADEONCP_START(pScrn, info);
 	}
 #endif
-	RADEONAdjustFrame(indx, 0, 0, 0);
+	RADEONAdjustFrame(indx, 0, 0);
 	info->DGAactive = FALSE;
     } else {
 	if (!info->DGAactive) {  /* save the old parameters */
@@ -327,7 +327,7 @@
 					    : pMode->depth);
 	/* RADEONModeInit() will set the mode field */
 
-	RADEONSwitchMode(indx, pMode->mode, 0);
+	RADEONSwitchMode(indx, pMode->mode);
 
 #ifdef XF86DRI
 	if (info->directRenderingEnabled) {
@@ -357,7 +357,7 @@
 {
     RADEONInfoPtr  info = RADEONPTR(pScrn);
 
-    RADEONAdjustFrame(pScrn->pScreen->myNum, x, y, flags);
+    RADEONAdjustFrame(pScrn->pScreen->myNum, x, y);
     info->DGAViewportStatus = 0;  /* FIXME */
 }
