From ef95f1c3737d9efc7d97fb1784f80ef3540a846b Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Sat, 13 Apr 2013 15:13:06 -0700
Subject: [PATCH:libXxf86vm 1/8] When Xcalloc() returns NULL, you don't need
 to Xfree() it

I have no words to explain how this ever happened.

Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Peter Hutterer <peter.hutterer@who-t.net>
---
 src/XF86VMode.c |    5 -----
 1 file changed, 5 deletions(-)

diff --git a/src/XF86VMode.c b/src/XF86VMode.c
index 4f19cf3..c0e50e6 100644
--- a/src/XF86VMode.c
+++ b/src/XF86VMode.c
@@ -256,7 +256,6 @@ XF86VidModeGetModeLine(Display* dpy, int screen, int* dotclock,
     if (modeline->privsize > 0) {
 	if (!(modeline->private = Xcalloc(modeline->privsize, sizeof(INT32)))) {
 	    _XEatData(dpy, (modeline->privsize) * sizeof(INT32));
-	    Xfree(modeline->private);
 	    return False;
 	}
 	_XRead(dpy, (char*)modeline->private, modeline->privsize * sizeof(INT32));
@@ -321,7 +320,6 @@ XF86VidModeGetAllModeLines(Display* dpy, int screen, int* modecount,
             _XEatData(dpy, (rep.modecount) * sizeof(xXF86OldVidModeModeInfo));
 	else
             _XEatData(dpy, (rep.modecount) * sizeof(xXF86VidModeModeInfo));
-        Xfree(modelines);
         return False;
     }
     mdinfptr = (XF86VidModeModeInfo *) (
@@ -353,7 +351,6 @@ XF86VidModeGetAllModeLines(Display* dpy, int screen, int* modecount,
 	            if (!(modelines[i]->private =
 			    Xcalloc(oldxmdline.privsize, sizeof(INT32)))) {
 			_XEatData(dpy, (oldxmdline.privsize) * sizeof(INT32));
-			Xfree(modelines[i]->private);
 		    } else {
 			_XRead(dpy, (char*)modelines[i]->private,
 			     oldxmdline.privsize * sizeof(INT32));
@@ -384,7 +381,6 @@ XF86VidModeGetAllModeLines(Display* dpy, int screen, int* modecount,
 		    if (!(modelines[i]->private =
 			    Xcalloc(xmdline.privsize, sizeof(INT32)))) {
 			_XEatData(dpy, (xmdline.privsize) * sizeof(INT32));
-			Xfree(modelines[i]->private);
 		    } else {
 			_XRead(dpy, (char*)modelines[i]->private,
 			     xmdline.privsize * sizeof(INT32));
@@ -1039,7 +1035,6 @@ XF86VidModeGetDotClocks(Display* dpy, int screen, int *flagsPtr,
 
     if (!(dotclocks = (int*) Xcalloc(rep.clocks, sizeof(int)))) {
         _XEatData(dpy, (rep.clocks) * 4);
-        Xfree(dotclocks);
         return False;
     }
 
-- 
1.7.9.2

From a89b1ad3377bfef9bab52f15f98b00f6540d531a Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Sat, 13 Apr 2013 17:40:24 -0700
Subject: [PATCH:libXxf86vm 2/8] Improve error handling in
 XF86VidModeGetMonitor()

Ensure that when we return an error we unlock the display first, and
NULL out any pointers we freed in error cleanup.

Instead of adding these fixes to every error check, instead combine
the error handling cleanup into a single copy.

Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Peter Hutterer <peter.hutterer@who-t.net>
---
 src/XF86VMode.c |   82 ++++++++++++++++++++++++++-----------------------------
 1 file changed, 39 insertions(+), 43 deletions(-)

diff --git a/src/XF86VMode.c b/src/XF86VMode.c
index c0e50e6..165f8ba 100644
--- a/src/XF86VMode.c
+++ b/src/XF86VMode.c
@@ -856,6 +856,7 @@ XF86VidModeGetMonitor(Display* dpy, int screen, XF86VidModeMonitor* monitor)
     xXF86VidModeGetMonitorReq *req;
     CARD32 syncrange;
     int i;
+    Bool result = True;
 
     XF86VidModeCheckExtension (dpy, info, False);
 
@@ -875,63 +876,58 @@ XF86VidModeGetMonitor(Display* dpy, int screen, XF86VidModeMonitor* monitor)
     monitor->bandwidth = (float)rep.bandwidth / 1e6;
 #endif
     if (rep.vendorLength) {
-	if (!(monitor->vendor = (char *)Xcalloc(rep.vendorLength + 1, 1))) {
-	    _XEatData(dpy, (rep.nhsync + rep.nvsync) * 4 +
-		      ((rep.vendorLength+3) & ~3) + ((rep.modelLength+3) & ~3));
-	    return False;
-	}
+	monitor->vendor = Xcalloc(rep.vendorLength + 1, 1);
+	if (monitor->vendor == NULL)
+	    result = False;
     } else {
 	monitor->vendor = NULL;
     }
-    if (rep.modelLength) {
-	if (!(monitor->model = Xcalloc(rep.modelLength + 1, 1))) {
-	    _XEatData(dpy, (rep.nhsync + rep.nvsync) * 4 +
-		      ((rep.vendorLength+3) & ~3) + ((rep.modelLength+3) & ~3));
-	    if (monitor->vendor)
-		Xfree(monitor->vendor);
-	    return False;
-	}
+    if (result && rep.modelLength) {
+	monitor->model = Xcalloc(rep.modelLength + 1, 1);
+	if (monitor->model == NULL)
+	    result = False;
     } else {
 	monitor->model = NULL;
     }
-    if (!(monitor->hsync = Xcalloc(rep.nhsync, sizeof(XF86VidModeSyncRange)))) {
-	_XEatData(dpy, (rep.nhsync + rep.nvsync) * 4 +
-		  ((rep.vendorLength+3) & ~3) + ((rep.modelLength+3) & ~3));
-
-	if (monitor->vendor)
-	    Xfree(monitor->vendor);
-	if (monitor->model)
-	    Xfree(monitor->model);
-	return False;
+    if (result) {
+	monitor->hsync = Xcalloc(rep.nhsync, sizeof(XF86VidModeSyncRange));
+	monitor->vsync = Xcalloc(rep.nvsync, sizeof(XF86VidModeSyncRange));
+	if ((monitor->hsync == NULL) || (monitor->vsync == NULL))
+	    result = False;
+    } else {
+	monitor->hsync = monitor->vsync = NULL;
     }
-    if (!(monitor->vsync = Xcalloc(rep.nvsync, sizeof(XF86VidModeSyncRange)))) {
+    if (result == False) {
 	_XEatData(dpy, (rep.nhsync + rep.nvsync) * 4 +
 		  ((rep.vendorLength+3) & ~3) + ((rep.modelLength+3) & ~3));
-	if (monitor->vendor)
-	    Xfree(monitor->vendor);
-	if (monitor->model)
-	    Xfree(monitor->model);
+	Xfree(monitor->vendor);
+	monitor->vendor = NULL;
+	Xfree(monitor->model);
+	monitor->model = NULL;
 	Xfree(monitor->hsync);
-	return False;
-    }
-    for (i = 0; i < rep.nhsync; i++) {
-	_XRead(dpy, (char *)&syncrange, 4);
-	monitor->hsync[i].lo = (float)(syncrange & 0xFFFF) / 100.0;
-	monitor->hsync[i].hi = (float)(syncrange >> 16) / 100.0;
+	monitor->hsync = NULL;
+	Xfree(monitor->vsync);
+	monitor->vsync = NULL;
     }
-    for (i = 0; i < rep.nvsync; i++) {
-	_XRead(dpy, (char *)&syncrange, 4);
-	monitor->vsync[i].lo = (float)(syncrange & 0xFFFF) / 100.0;
-	monitor->vsync[i].hi = (float)(syncrange >> 16) / 100.0;
+    else {
+	for (i = 0; i < rep.nhsync; i++) {
+	    _XRead(dpy, (char *)&syncrange, 4);
+	    monitor->hsync[i].lo = (float)(syncrange & 0xFFFF) / 100.0;
+	    monitor->hsync[i].hi = (float)(syncrange >> 16) / 100.0;
+	}
+	for (i = 0; i < rep.nvsync; i++) {
+	    _XRead(dpy, (char *)&syncrange, 4);
+	    monitor->vsync[i].lo = (float)(syncrange & 0xFFFF) / 100.0;
+	    monitor->vsync[i].hi = (float)(syncrange >> 16) / 100.0;
+	}
+	if (rep.vendorLength)
+	    _XReadPad(dpy, monitor->vendor, rep.vendorLength);
+	if (rep.modelLength)
+	    _XReadPad(dpy, monitor->model, rep.modelLength);
     }
-    if (rep.vendorLength)
-	_XReadPad(dpy, monitor->vendor, rep.vendorLength);
-    if (rep.modelLength)
-	_XReadPad(dpy, monitor->model, rep.modelLength);
-
     UnlockDisplay(dpy);
     SyncHandle();
-    return True;
+    return result;
 }
 
 Bool
-- 
1.7.9.2

From 8ed00bd0a7c44c7fece687e2566d920ea74ef809 Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Sat, 13 Apr 2013 17:52:12 -0700
Subject: [PATCH:libXxf86vm 3/8] Unlock display before returning alloc error
 in XF86VidModeGetModeLine()

Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Peter Hutterer <peter.hutterer@who-t.net>
---
 src/XF86VMode.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/XF86VMode.c b/src/XF86VMode.c
index 165f8ba..28c79c1 100644
--- a/src/XF86VMode.c
+++ b/src/XF86VMode.c
@@ -203,6 +203,7 @@ XF86VidModeGetModeLine(Display* dpy, int screen, int* dotclock,
     xXF86OldVidModeGetModeLineReply oldrep;
     xXF86VidModeGetModeLineReq *req;
     int majorVersion, minorVersion;
+    Bool result = True;
 
     XF86VidModeCheckExtension (dpy, info, False);
     XF86VidModeQueryVersion(dpy, &majorVersion, &minorVersion);
@@ -254,17 +255,18 @@ XF86VidModeGetModeLine(Display* dpy, int screen, int* dotclock,
     }
 
     if (modeline->privsize > 0) {
-	if (!(modeline->private = Xcalloc(modeline->privsize, sizeof(INT32)))) {
+	modeline->private = Xcalloc(modeline->privsize, sizeof(INT32));
+	if (modeline->private == NULL) {
 	    _XEatData(dpy, (modeline->privsize) * sizeof(INT32));
-	    return False;
-	}
-	_XRead(dpy, (char*)modeline->private, modeline->privsize * sizeof(INT32));
+	    result = False;
+	} else
+	    _XRead(dpy, (char*)modeline->private, modeline->privsize * sizeof(INT32));
     } else {
 	modeline->private = NULL;
     }
     UnlockDisplay(dpy);
     SyncHandle();
-    return True;
+    return result;
 }
 
 Bool
-- 
1.7.9.2

From 6c82906f25abcb0f8ec92bcdaf1872bd8b63ca5d Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Sat, 13 Apr 2013 17:54:45 -0700
Subject: [PATCH:libXxf86vm 4/8] Unlock display before returning alloc error
 in XF86VidModeGetAllModeLines()

Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Peter Hutterer <peter.hutterer@who-t.net>
---
 src/XF86VMode.c |    2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/XF86VMode.c b/src/XF86VMode.c
index 28c79c1..76276b6 100644
--- a/src/XF86VMode.c
+++ b/src/XF86VMode.c
@@ -322,6 +322,8 @@ XF86VidModeGetAllModeLines(Display* dpy, int screen, int* modecount,
             _XEatData(dpy, (rep.modecount) * sizeof(xXF86OldVidModeModeInfo));
 	else
             _XEatData(dpy, (rep.modecount) * sizeof(xXF86VidModeModeInfo));
+	UnlockDisplay(dpy);
+	SyncHandle();
         return False;
     }
     mdinfptr = (XF86VidModeModeInfo *) (
-- 
1.7.9.2

From d0355b28dd53fba6fb29c350e090ed4a73d4c480 Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Sat, 13 Apr 2013 17:58:28 -0700
Subject: [PATCH:libXxf86vm 5/8] Unlock display before returning alloc error
 in XF86VidModeGetDotClocks()

Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Peter Hutterer <peter.hutterer@who-t.net>
---
 src/XF86VMode.c |   17 ++++++++++-------
 1 file changed, 10 insertions(+), 7 deletions(-)

diff --git a/src/XF86VMode.c b/src/XF86VMode.c
index 76276b6..1b907f4 100644
--- a/src/XF86VMode.c
+++ b/src/XF86VMode.c
@@ -1014,6 +1014,7 @@ XF86VidModeGetDotClocks(Display* dpy, int screen, int *flagsPtr,
     xXF86VidModeGetDotClocksReq *req;
     int i, *dotclocks;
     CARD32 dotclk;
+    Bool result = True;
 
     XF86VidModeCheckExtension (dpy, info, False);
 
@@ -1033,19 +1034,21 @@ XF86VidModeGetDotClocks(Display* dpy, int screen, int *flagsPtr,
     *maxclocksPtr = rep.maxclocks;
     *flagsPtr     = rep.flags;
 
-    if (!(dotclocks = (int*) Xcalloc(rep.clocks, sizeof(int)))) {
+    dotclocks = Xcalloc(rep.clocks, sizeof(int));
+    if (dotclocks == NULL) {
         _XEatData(dpy, (rep.clocks) * 4);
-        return False;
+        result = False;
     }
-
-    for (i = 0; i < rep.clocks; i++) {
-        _XRead(dpy, (char*)&dotclk, 4);
-	dotclocks[i] = dotclk;
+    else {
+	for (i = 0; i < rep.clocks; i++) {
+	    _XRead(dpy, (char*)&dotclk, 4);
+	    dotclocks[i] = dotclk;
+	}
     }
     *clocksPtr = dotclocks;
     UnlockDisplay(dpy);
     SyncHandle();
-    return True;
+    return result;
 }
 
 Bool
-- 
1.7.9.2

