From 46ed6283034b5b7d14584009453f5d974cfacf1e Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Sat, 13 Apr 2013 11:05:27 -0700
Subject: [PATCH:libXtst 1/2] Use _XEatDataWords to eat data in error cases

Avoids having to do calculcations based on response contents

Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
---
 configure.ac  |    6 ++++++
 src/XRecord.c |   23 +++++++++++++++++------
 2 files changed, 23 insertions(+), 6 deletions(-)

diff --git a/configure.ac b/configure.ac
index 7ef0153..d83d4d8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -47,6 +47,12 @@ XORG_CHECK_SGML_DOCTOOLS(1.8)
 # Obtain compiler/linker options for depedencies
 PKG_CHECK_MODULES(XTST, x11 [xext >= 1.0.99.4] xi [recordproto >= 1.13.99.1] [xextproto >= 7.0.99.3] inputproto)
 
+# Check for _XEatDataWords function that may be patched into older Xlib release
+SAVE_LIBS="$LIBS"
+LIBS="$XTST_LIBS"
+AC_CHECK_FUNCS([_XEatDataWords])
+LIBS="$SAVE_LIBS"
+
 # Determine if the source for man pages is available
 # It may already be present (tarball) or can be generated using xmlto
 AM_CONDITIONAL([INSTALL_MANPAGES],
diff --git a/src/XRecord.c b/src/XRecord.c
index b65451c..ba628b6 100644
--- a/src/XRecord.c
+++ b/src/XRecord.c
@@ -49,6 +49,9 @@ from The Open Group.
  * By Stephen Gildea, X Consortium, and Martha Zimet, NCD.
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
 #include <stdio.h>
 #include <assert.h>
 #include <X11/Xlibint.h>
@@ -56,6 +59,18 @@ from The Open Group.
 #include <X11/extensions/extutil.h>
 #include <X11/extensions/recordproto.h>
 #include <X11/extensions/record.h>
+#include <limits.h>
+
+#ifndef HAVE__XEATDATAWORDS
+static inline void _XEatDataWords(Display *dpy, unsigned long n)
+{
+# ifndef LONG64
+    if (n >= (ULONG_MAX >> 2))
+        _XIOError(dpy);
+# endif
+    _XEatData (dpy, n << 2);
+}
+#endif
 
 static XExtensionInfo _xrecord_info_data;
 static XExtensionInfo *xrecord_info = &_xrecord_info_data;
@@ -427,7 +442,7 @@ XRecordGetContext(Display *dpy, XRecordContext context,
 
     ret = (XRecordState*)Xmalloc(sizeof(XRecordState));
     if (!ret) {
-	/* XXX - eat data */
+	_XEatDataWords (dpy, rep.length);
 	UnlockDisplay(dpy);
 	SyncHandle();
 	return 0;
@@ -446,11 +461,7 @@ XRecordGetContext(Display *dpy, XRecordContext context,
 	}
         if (!client_inf || !client_inf_str)
         {
-           for(i = 0; i < count; i++)
-           {
-	        _XEatData (dpy, sizeof(xRecordClientInfo));
-                _XEatData (dpy, SIZEOF(xRecordRange)); /* XXX - don't know how many */
-           }
+	   _XEatDataWords (dpy, rep.length);
 	   UnlockDisplay(dpy);
 	   XRecordFreeState(ret);
 	   SyncHandle();
-- 
1.7.9.2

From e7e04b7be3f018ad636aba3a36bfc1cd80b9906d Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Sat, 13 Apr 2013 11:27:26 -0700
Subject: [PATCH:libXtst 2/2] integer overflow in XRecordGetContext()
 [CVE-2013-2063]

The nclients and nranges members of the reply are both CARD32 and need
to be bounds checked before multiplying by the size of the structs to
avoid integer overflow leading to underallocation and writing data from
the network past the end of the allocated buffer.

Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
---
 src/XRecord.c |   32 +++++++++++++++++++++-----------
 1 file changed, 21 insertions(+), 11 deletions(-)

diff --git a/src/XRecord.c b/src/XRecord.c
index ba628b6..5bbd5ac 100644
--- a/src/XRecord.c
+++ b/src/XRecord.c
@@ -420,11 +420,9 @@ XRecordGetContext(Display *dpy, XRecordContext context,
     XExtDisplayInfo 	*info = find_display (dpy);
     register 		xRecordGetContextReq   	*req;
     xRecordGetContextReply 	rep;
-    int			count, i, rn;
+    unsigned int	count, i, rn;
     xRecordRange   	xrange;
-    XRecordRange	*ranges = NULL;
     xRecordClientInfo   xclient_inf;
-    XRecordClientInfo	**client_inf, *client_inf_str = NULL;
     XRecordState	*ret;
 
     XRecordCheckExtension (dpy, info, 0);
@@ -454,13 +452,18 @@ XRecordGetContext(Display *dpy, XRecordContext context,
 
     if (count)
     {
-     	client_inf = (XRecordClientInfo **) Xcalloc(count, sizeof(XRecordClientInfo*));
-	ret->client_info = client_inf;
-	if (client_inf != NULL) {
-	    client_inf_str = (XRecordClientInfo *) Xmalloc(count*sizeof(XRecordClientInfo));
+	XRecordClientInfo	**client_inf = NULL;
+	XRecordClientInfo	*client_inf_str = NULL;
+
+	if (count < (INT_MAX / sizeof(XRecordClientInfo))) {
+	    client_inf = Xcalloc(count, sizeof(XRecordClientInfo *));
+	    if (client_inf != NULL)
+		client_inf_str = Xmalloc(count * sizeof(XRecordClientInfo));
 	}
+	ret->client_info = client_inf;
         if (!client_inf || !client_inf_str)
         {
+	   free(client_inf);
 	   _XEatDataWords (dpy, rep.length);
 	   UnlockDisplay(dpy);
 	   XRecordFreeState(ret);
@@ -476,11 +479,18 @@ XRecordGetContext(Display *dpy, XRecordContext context,
 
 	    if (xclient_inf.nRanges)
 	    {
-		client_inf_str[i].ranges = (XRecordRange**) Xcalloc(xclient_inf.nRanges, sizeof(XRecordRange*));
-		if (client_inf_str[i].ranges != NULL) {
-		    ranges = (XRecordRange*)
-			Xmalloc(xclient_inf.nRanges * sizeof(XRecordRange));
+		XRecordRange	*ranges = NULL;
+
+		if (xclient_inf.nRanges < (INT_MAX / sizeof(XRecordRange))) {
+		    client_inf_str[i].ranges =
+			Xcalloc(xclient_inf.nRanges, sizeof(XRecordRange *));
+		    if (client_inf_str[i].ranges != NULL)
+			ranges =
+			    Xmalloc(xclient_inf.nRanges * sizeof(XRecordRange));
 		}
+		else
+		    client_inf_str[i].ranges = NULL;
+
 		if (!client_inf_str[i].ranges || !ranges) {
 		    /* XXX eat data */
 		    UnlockDisplay(dpy);
-- 
1.7.9.2

