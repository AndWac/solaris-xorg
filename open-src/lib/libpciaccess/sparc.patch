--- src/solx_devfs.c	Tue Aug 14 10:11:53 2012
+++ src/solx_devfs.c	Fri Aug 17 11:55:38 2012
@@ -84,6 +84,14 @@
     struct pci_device_private * volatile devices;
 } probe_info_t;
 
+#ifdef __sparc
+typedef struct bdf_table_info {
+    int bus;
+    int dev;
+    int func;
+} bdf_table_info_t;
+#endif
+
 static nexus_t *nexus_list = NULL;
 #if !defined(__sparc)
 static int xsvc_fd = -1;
@@ -91,6 +99,9 @@
 
 #ifdef __sparc
 static di_prom_handle_t di_phdl;
+static bdf_table_info_t *bdf_table = NULL;
+static size_t  num_bdfs = 0;
+static size_t  num_allocated_bdfs = 0;
 #endif
 
 /*
@@ -251,7 +262,47 @@
     return (rval);
 }
 
+#ifdef __sparc
+static int
+create_bdf_table(di_node_t node, void *arg)
+{
+    int *regbuf = NULL;
+    int len = 0;
 
+    len = di_prop_lookup_ints(DDI_DEV_T_ANY, node, "reg", &regbuf);
+
+    if ((len <= 0) && di_phdl)
+	len = di_prom_prop_lookup_ints(di_phdl, node, "reg", &regbuf);
+
+    /* Exclude usb devices */
+    if (len < 5) {
+    	return (DI_WALK_CONTINUE);
+    }
+
+    bdf_table[num_bdfs].bus = PCI_REG_BUS_G(regbuf[0]);
+    bdf_table[num_bdfs].dev = PCI_REG_DEV_G(regbuf[0]);
+    bdf_table[num_bdfs].func  = PCI_REG_FUNC_G(regbuf[0]);
+
+    if (++num_bdfs == num_allocated_bdfs) {
+	bdf_table_info_t  *new_bdfs;
+	size_t new_num_bdfs = num_allocated_bdfs * 2;
+
+	new_bdfs = realloc (bdf_table,
+                   new_num_bdfs * sizeof (bdf_table_info_t));
+	if (new_bdfs == NULL)
+	    return (DI_WALK_TERMINATE);
+
+	(void) memset(&new_bdfs[num_bdfs], 0,
+                   num_allocated_bdfs *
+                   sizeof (bdf_table_info_t));
+	num_allocated_bdfs = new_num_bdfs;
+	bdf_table = new_bdfs;
+    }
+
+    return (DI_WALK_CONTINUE);
+}
+#endif
+
 /*
  * Probe device's functions.  Modifies many fields in the prg_p.
  */
@@ -276,12 +327,32 @@
      * will force the loop as the user wants a specific function to be
      * checked.
      */
+
     for (func = first_func, multi_function_device = B_FALSE;
 	 ((func <= last_func) &&
 	  ((func == first_func) || (multi_function_device)));
 	 func++) {
+#ifdef __sparc
+	int i;
+#endif
+
 	prg_p->func_no = func;
 
+#ifdef __sparc
+	/* Check validity of bdf */
+	for (i = 0; i < num_bdfs; i++) {
+	    if ((bdf_table[i].bus == prg_p->bus_no) && 
+		(bdf_table[i].dev == prg_p->dev_no) &&
+		(bdf_table[i].func == prg_p->func_no))
+		break;
+	}
+
+	/* Skipping if bdf device not on devinfo tree */
+	if (i == num_bdfs) {
+	    continue;
+	}
+#endif
+	    
 	/*
 	 * Four things can happen here:
 	 *
@@ -551,6 +622,7 @@
     int bus_range_found = 0;
     int device_type_found = 0;
     di_prom_prop_t prom_prop;
+    di_node_t rnode =  DI_NODE_NIL;
 #endif
 
 
@@ -674,6 +746,25 @@
 	nexus_dev_path = di_devfs_path(di_node);
 	nexus->dev_path = strdup(nexus_dev_path);
 	di_devfs_path_free(nexus_dev_path);
+
+#ifdef __sparc
+	if ((rnode = di_init(nexus->dev_path, DINFOCPYALL)) == DI_NODE_NIL) {
+	    (void) fprintf(stderr, "di_init failed: %s\n", strerror(errno));
+	    return (DI_WALK_TERMINATE);
+	}
+
+	if ((bdf_table = calloc(INITIAL_NUM_DEVICES,
+			sizeof (bdf_table_info_t))) == NULL) {
+	    di_fini(rnode);
+	    return (DI_WALK_TERMINATE);
+	}
+	num_bdfs = 0;
+	num_allocated_bdfs = INITIAL_NUM_DEVICES;
+
+	/* Create a bdf table for the nexus node */
+	(void) di_walk_node(rnode, DI_WALK_CLDFIRST, (void *)NULL, create_bdf_table);
+#endif 
+
 	if ((do_probe(nexus, pinfo) != 0) && (errno != ENXIO)) {
 	    (void) fprintf(stderr, "Error probing node %s: %s\n",
 			   nexus_path, strerror(errno));
@@ -685,6 +776,15 @@
 	    nexus->next = nexus_list;
 	    nexus_list = nexus;
 	}
+#ifdef __sparc
+	if (bdf_table) {
+	    free (bdf_table);
+	    bdf_table = NULL;
+	    num_bdfs = 0;
+	    num_allocated_bdfs = 0;
+	}
+	di_fini(rnode);
+#endif
     } else {
 	(void) fprintf(stderr, "Error opening %s: %s\n",
 		       nexus_path, strerror(errno));
